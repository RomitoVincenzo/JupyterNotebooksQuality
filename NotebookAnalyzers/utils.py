import json
import ast
from notebooktoall.transform import transform_notebook


def notebook_to_json(filename):
    """The function takes the .ipynb file and returns it as a dictionary python object"""
    f = open("../TargetNotebooks/" + filename, )
    data = json.load(f)
    f.close()
    return data


# def notebookToCode(data):
#    """The function takes the JSON of the target notebook and returns a python code string"""
#    code=[]
#    for cell in data["cells"]:
#        if cell["cell_type"] == 'code':
#            code.append(''.join(cell["source"]))
#    code = '\n'.join(code)
#    return code

def notebook_to_code(filename):
    """The function takes the name of the desired .ipynb file in the target notebooks folder,
    and returns the python code syntax tree"""
    transform_notebook(ipynb_file="../TargetNotebooks/" + filename, export_list=["py"])
    f = open(filename.replace(".ipynb", ".py"), 'r')
    py_code = f.read()
    f.close()
    return py_code


def functions_number(code):
    """The function takes a python code string and returns the number of function definitions"""
    tree = ast.parse(code)
    f_num = sum(isinstance(exp, ast.FunctionDef) for exp in tree.body)
    return f_num


def not_executed_cells(notebook):
    """The function takes a dict representing a notebook and returns the number of non-executed cells"""
    not_exec_cells = 0
    for cell in notebook["cells"]:
        if cell["cell_type"] == 'code':
            if cell['execution_count'] is None and cell['source'] != []:
                not_exec_cells = not_exec_cells + 1  # This is a not executed Python Cell containing actual code
    return not_exec_cells


def empty_cells(notebook):
    """The function takes a dict representing a notebook and returns the number of empty cells"""
    empty_cell = 0
    for cell in notebook["cells"]:
        if cell["cell_type"] == 'code':
            if cell['execution_count'] is None and cell['source'] == []:
                empty_cell = empty_cell + 1  # This is an empty Python Cell
    return empty_cell


def markdown_lines(notebook):
    """The function takes a dict representing a notebook and returns the number of markdown lines"""
    markdowns = 0
    for cell in notebook["cells"]:
        if cell["cell_type"] == 'markdown':
            rows = len(cell['source'])
            markdowns = markdowns + rows
    return markdowns


def markdown_titles(notebook):
    """The function takes a dict representing a notebook and returns the number of markdown titles"""
    titles = 0
    for cell in notebook["cells"]:
        if cell["cell_type"] == 'markdown':
            for row in cell['source']:
                if row.lstrip().startswith('#'):
                    titles = titles + 1
    return titles


def markdown_distribution(notebook):
    """The function takes a dict representing a notebook and, dividing the notebook in four sections, 
    returns the percentage of markdown rows in each section out of the total markdown rows"""
    n_md_cells = 0
    markdown_fir = 0
    markdown_sec = 0
    markdown_thi = 0
    markdown_fou = 0
    cells_number = len(notebook["cells"])
    cells_per_portion = int(cells_number / 4)
    cell_count = 0
    cell_portion = 1
    for cell in notebook["cells"]:
        if cell["cell_type"] == 'markdown':
            n_md_cells = n_md_cells + 1
            if cell_portion == 1:
                markdown_fir = markdown_fir + len(cell['source'])
            elif cell_portion == 2:
                markdown_sec = markdown_sec + len(cell['source'])
            elif cell_portion == 3:
                markdown_thi = markdown_thi + len(cell['source'])
            else:
                markdown_fou = markdown_fou + len(cell['source'])
        cell_count = cell_count + 1
        if cell_count >= cells_per_portion:
            if cell_portion < 4:
                cell_count = 0
                cell_portion = cell_portion + 1
            else:
                break
    total_md_rows = markdown_fir + markdown_sec + markdown_thi + markdown_fou
    if n_md_cells < 4:
        return None, None, None, None
    else:
        return markdown_fir/total_md_rows, markdown_sec/total_md_rows, \
               markdown_thi/total_md_rows, markdown_fou/total_md_rows


def imports_correct_position(code):
    """The function takes a python code string and returns True if there are no imports other than those in the first
    cell of code and False otherwise """
    found_first_cell = False  # when True it means we found the first cell of code that has to be ignored
    second_cell_not_reached = True
    # when set to False we are actually reading instructions from the second cell of
    # code, from now on we need to analyze all the cells looking for import statements
    correct_position = True
    cell = ''
    program = code.split('\n')
    for line in program:
        if not found_first_cell:
            # it ignores all the lines before the first cell generated by nbconvert(python# version ecc.)
            if line[0:5] == '# In[':
                found_first_cell = True
        elif not second_cell_not_reached:
            # starting from the second cell it saves all the instructions until it find a new cell
            if line[0:5] != '# In[':
                cell = cell + '\n' + line
            else:
                tree = ast.parse(cell)
                # once it finds a new cell it verifies if there are any imports statement in the previous cell
                if sum(isinstance(exp, ast.Import) for exp in tree.body) > 0:
                    correct_position = False
                    break
        else:
            if line[0:5] == '# In[':
                # following instructions are from the second cell of code, the first one we have to analyze
                second_cell_not_reached = False
    return correct_position


def cells_correct_order(notebook):
    """The function takes a dict representing notebook dictionary, it returns True if the cells are executed in
    sequential order,starting from 1, and False otherwise """
    correct_exec = True
    counter = 1
    for cell in notebook["cells"]:
        if cell["cell_type"] == 'code':
            if counter == cell['execution_count']:
                counter = counter + 1
            else:
                if cell['source']:
                    correct_exec = False
    return correct_exec


def classes_number(code):
    """The function takes a python code string and returns the number of class definitions"""
    tree = ast.parse(code)
    class_def_num = sum(isinstance(exp, ast.ClassDef) for exp in tree.body)
    return class_def_num
